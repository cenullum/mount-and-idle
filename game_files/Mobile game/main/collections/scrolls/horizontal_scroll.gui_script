local druid = require("druid.druid")
local data_manager = require("main.data_manager")
local monarch = require "monarch.monarch"



function handle_drag_move(drag_component,dx, dy)
    -- Bileşenin bağlı olduğu düğümü al
    local node = drag_component:get_node()
    -- Düğümün mevcut pozisyonunu al
    local current_pos = gui.get_position(node)
    -- Pozisyonu delta değerleri kadar güncelle
    current_pos.x = current_pos.x + dx
    current_pos.y = current_pos.y + dy
    -- Düğümün yeni pozisyonunu ayarla
    gui.set_position(node, current_pos)
end


function remove_element(self, data)
    -- Contract'ta hero var mı kontrol et
    local assigned_hero = nil
    for i, zone in ipairs(self.drop_zones) do
        if zone.node == data.root then
            assigned_hero = zone.assigned_hero
            break
        end
    end

    if assigned_hero then
        -- Hero varsa onu orijinal pozisyonuna geri gönder
        local hero_drag_data = self.element_drag_data[assigned_hero]
        if hero_drag_data then
            gui.set_parent(assigned_hero, hero_drag_data.parent, true)
            gui.animate(assigned_hero, "position", hero_drag_data.start_position, gui.EASING_OUTBACK, 0.3)
            print("Hero orijinal pozisyonuna geri gönderildi:", assigned_hero)
        end
        
        -- Zone'dan hero assignment'ını kaldır
        for i, zone in ipairs(self.drop_zones) do
            if zone.node == data.root then
                zone.assigned_hero = nil
                zone.is_active = true -- Zone'u tekrar aktif yap
                break
            end
        end
    else
        -- Hero yoksa contract'ı animasyonla sil
        -- 1. Önce fade out animasyonu yap
        gui.animate(data.root, "color.w", 0, gui.EASING_OUTSINE, 0.3, 0, function()
            -- Animasyon tamamlandığında silme işlemlerini yap
            
            -- 2. Druid bileşenini (butonu) Druid yönetiminden kaldır
            self.druid:remove(data.button_component)

            -- 3. İlgili veriyi `drop_zones` tablosundan bul ve sil (indekse güvenme!)
            for i, zone in ipairs(self.drop_zones) do
                if zone.node == data.root then
                    table.remove(self.drop_zones, i)
                    self.contract_grid:remove(i)
                    break -- Elemanı bulduktan sonra döngüden çık
                end
            end

            -- 4. GUI düğümünü ve altındaki her şeyi sil
            -- grid:remove() çağrısına gerek yok, bind_grid bunu halleder.
            gui.delete_node(data.root)

            print("Contract başarıyla silindi:", data.root)
        end)
    end
end




local function add_contract_element(self, data)
    local prefab_nodes = gui.clone_tree(self.prefab)
    local root = prefab_nodes["box"]
    gui.set_enabled(root, true)
    local contract_name = prefab_nodes["contract_name"]
    local destroy_button = prefab_nodes["destroy_button"]



    -- ÖNEMLİ: Buton bileşenini bir değişkende sakla
    local button_component = self.druid:new_button(destroy_button)

    -- Butonun on_click olayına, kendisini de içeren veriyi gönder
    button_component.on_click:subscribe(function()
        -- Fonksiyonu `self` bağlamında ve doğru veriyle çağır
        remove_element(self, {
            root = root,
            button_component = button_component -- Buton referansını buraya ekle
        })
    end)
    
    gui.set_text(contract_name, data.text)
    
    -- Set contract image from JSON data
    if data.contract_data and data.contract_data.atlas and data.contract_data.flipbook then
        gui.set_texture(root, data.contract_data.atlas)
        gui.play_flipbook(root, data.contract_data.flipbook)
    end
    
    self.contract_grid:add(root)
    
    -- Register as a dynamic drop zone
    local new_index = #self.drop_zones + 1
    self.drop_zones[new_index] = {
        node = root,
        name = data.text,
        color = vmath.vector4(1, 1, 1, 1),
        hover_color = vmath.vector4(1, 1, 1, 0.4),
        is_hovered = false,
        is_active = true,
        assigned_hero = nil, -- Track which hero is assigned to this contract
    }
end


local function on_timer_finished(self, timer,timer_node)
    gui.set_visible(timer_node, false)
end

local function add_hero_element(self, data)
    local prefab_nodes = gui.clone_tree(self.prefab)
    local root = prefab_nodes["box"]
    gui.set_enabled(root, true)
    local contract_name=prefab_nodes["contract_name"]
    local destroy_button=prefab_nodes["destroy_button"]
    gui.set_enabled(destroy_button, false)
    gui.set_text(contract_name, data.text)
    local position_name=gui.get_position(contract_name)
    position_name.y=position_name.y-200
    gui.set_position(contract_name, position_name)
    -- Set hero image from JSON data
    if data.hero_data and data.hero_data.atlas and data.hero_data.flipbook then
        gui.set_texture(root, data.hero_data.atlas)
        gui.play_flipbook(root, data.hero_data.flipbook)
    end
    
    self.hero_grid:add(root)


    -- Create drag data for this specific element
    local element_drag_data = {}
    element_drag_data.parent=gui.get_parent(root)
    element_drag_data.drag = self.druid:new_drag(root, function(_, dx, dy, x,y,touch)
        local position_x = gui.get(element_drag_data.drag.node, "position.x")
        local position_y = gui.get(element_drag_data.drag.node, "position.y")
        gui.set(element_drag_data.drag.node, "position.x", position_x + dx)
        gui.set(element_drag_data.drag.node, "position.y", position_y + dy)
        
        -- Hover kontrolü: aktif drop zone'lar üzerinde mi? (sadece hero atanmamış olanlar)

        for _, zone in ipairs(self.drop_zones) do
            if zone.is_active and not zone.assigned_hero then
                local is_over = gui.pick_node(zone.node, touch.x, touch.y)
                if is_over and not zone.is_hovered then
                    zone.is_hovered = true
                    gui.animate(zone.node, "color", zone.hover_color, gui.EASING_OUTSINE, 0.2)
                elseif (not is_over) and zone.is_hovered then
                    zone.is_hovered = false
                    gui.animate(zone.node, "color", zone.color, gui.EASING_OUTSINE, 0.2)
                end
            end
        end
    end)

    element_drag_data.drag.on_drag_start:subscribe(function(_, _, _, touch)
        gui.set_parent(root, self.drag_parent or nil, true)
    end)


    -- Save start position for this specific element
    element_drag_data.start_position = gui.get_position(element_drag_data.drag.node)
    
    -- Subscribe to drag end event for this specific element
    element_drag_data.drag.on_drag_end:subscribe(function(_, _, _, touch)
        -- Drop zone tespiti
        local dropped_zone = nil
        if touch then
            for _, zone in ipairs(self.drop_zones) do
                if zone.is_active and not zone.assigned_hero and gui.pick_node(zone.node, touch.x, touch.y) then
                    dropped_zone = zone
                    break
                end
            end
        end

        if dropped_zone then
            if self.on_item_dropped then
                self:on_item_dropped(dropped_zone.name, root)
            end
            -- Hero'yu zone'a ata
            dropped_zone.assigned_hero = root
            dropped_zone.is_active = false -- Zone'u inaktif yap (daha fazla hero kabul etmesin)
            
            -- Zone'a parent et ve hedef konuma animasyonla (x hizalı, y 50px aşağı)
            gui.set_parent(root, dropped_zone.node, true)
            local current_pos = gui.get_position(element_drag_data.drag.node)
            local target = vmath.vector3(0, -100, current_pos.z)
            element_drag_data.timer=self.druid:new_timer(prefab_nodes["timer"], 60,0,on_timer_finished)
            gui.animate(element_drag_data.drag.node, "position", target, gui.EASING_OUTBACK, 0.25)
            -- Drop animasyonu (zone feedback)
            gui.set_scale(dropped_zone.node, vmath.vector3(1.2))
            gui.animate(dropped_zone.node, "scale", vmath.vector3(1), gui.EASING_OUTBACK, 0.3)
        else
            -- Hero bir contract'tan geri alınıyor mu kontrol et
            for _, zone in ipairs(self.drop_zones) do
                if zone.assigned_hero == root then
                    zone.assigned_hero = nil
                    zone.is_active = true -- Zone'u tekrar aktif yap
                    break
                end
            end
            
            -- Hover efektlerini sıfırla ve orijinal parent/pozisyona dön
            gui.animate(element_drag_data.drag.node, "position", element_drag_data.start_position, gui.EASING_OUTBACK, 0.3)
            gui.set_parent(root, element_drag_data.parent or nil, true)
        end

        -- Hover efektlerini sıfırla
        for _, zone in ipairs(self.drop_zones) do
            if zone.is_hovered then
                zone.is_hovered = false
                gui.animate(zone.node, "color", zone.color, gui.EASING_OUTSINE, 0.2)
            end
        end
    end)
    
    -- Store drag data for this element using the root node as key
    self.element_drag_data[root] = element_drag_data

end

local function on_click(self,params,button)
    msg.post("scene_manager:/scene_loader#monarch",params)
end

function init(self)
    -- Initialize data manager first
    data_manager.init()
    math.randomseed(os.time())
    self.druid = druid.new(self)
    self.hero_scroll = self.druid:new_scroll("hero_scroll", "hero_content")
    self.contract_scroll = self.druid:new_scroll("contract_scroll", "contract_content")
    self.map_button = self.druid:new_button("map_button", on_click,"map_menu")

    self.drag_parent = gui.get_node("drag_parent")
    print(self.drag_parent," drag_parent")
    self.prefab = gui.get_node("box") -- Root of the element prefab
    gui.set_enabled(self.prefab, false)
    self.contract_grid = self.druid:new_grid("contract_content", self.prefab, 30)
    self.hero_grid = self.druid:new_grid("hero_content", self.prefab, 30) -- The self.prefab is a node that will be cloned to create grid elements
    self.hero_scroll:bind_grid(self.hero_grid) -- Bind the grid to the scroll
    self.contract_scroll:bind_grid(self.contract_grid) -- Bind the grid to the scroll

    -- Initialize dynamic storages
    self.element_drag_data = {}
    self.drop_zones = {}

    -- Load heroes from JSON data
    local heroes = data_manager.get_all_heroes()
    for _, hero in ipairs(heroes) do
        add_hero_element(self, { text = hero.name, hero_data = hero })
    end

    -- Load initial contracts from JSON data
    local initial_contracts = data_manager.spawn_random_contracts(5)
    for _, contract in ipairs(initial_contracts) do
        add_contract_element(self, { text = contract.name, contract_data = contract })
    end
    
    -- Add mandatory contracts
    local mandatory_contracts = data_manager.get_mandatory_contracts()
    for _, contract in ipairs(mandatory_contracts) do
        add_contract_element(self, { text = contract.name, contract_data = contract })
    end
    
end

function final(self)
    self.druid:final()
end

function update(self, dt)
    self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
    self.druid:on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
    return self.druid:on_input(action_id, action)
end


-- Basit drop callback (kullanıcı override edebilir)
function on_item_dropped(self, zone_name, hero_root)
    -- Burada oyun mantığına göre eşleştirme/atama yapılabilir
end


