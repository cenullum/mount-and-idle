local druid = require("druid.druid")

function handle_drag_move(drag_component,dx, dy)
    -- Bileşenin bağlı olduğu düğümü al
    local node = drag_component:get_node()
    -- Düğümün mevcut pozisyonunu al
    local current_pos = gui.get_position(node)
    -- Pozisyonu delta değerleri kadar güncelle
    current_pos.x = current_pos.x + dx
    current_pos.y = current_pos.y + dy
    -- Düğümün yeni pozisyonunu ayarla
    gui.set_position(node, current_pos)
end




local function add_contract_element(self, data)
    local prefab_nodes = gui.clone_tree(self.prefab)
    local root = prefab_nodes["box"]
    gui.set_enabled(root, true)
    local contract_name=prefab_nodes["contract_name"]
    gui.set_text(contract_name, data.text)
    self.contract_grid:add(root)
    -- Register as a dynamic drop zone
    self.drop_zones[#self.drop_zones + 1] = {
        node = root,
        name = data.text,
        color = vmath.vector4(1, 1, 1, 1),
        hover_color = vmath.vector4(1, 1, 1, 0.4),
        is_hovered = false,
        is_active = true,
    }
end


local function add_hero_element(self, data)
    local prefab_nodes = gui.clone_tree(self.prefab)
    local root = prefab_nodes["box"]
    gui.set_enabled(root, true)
    local contract_name=prefab_nodes["contract_name"]
    local destroy_name=prefab_nodes["destroy_button"]
    gui.set_visible(destroy_name, false)
    gui.set_text(contract_name, data.text)
    self.hero_grid:add(root)

    
    -- Create drag data for this specific element
    local element_drag_data = {}
    element_drag_data.parent=gui.get_parent(root)
    element_drag_data.drag = self.druid:new_drag(root, function(_, dx, dy, x,y,touch)
        local position_x = gui.get(element_drag_data.drag.node, "position.x")
        local position_y = gui.get(element_drag_data.drag.node, "position.y")
        gui.set(element_drag_data.drag.node, "position.x", position_x + dx)
        gui.set(element_drag_data.drag.node, "position.y", position_y + dy)
        
        -- Hover kontrolü: aktif drop zone'lar üzerinde mi?

        for _, zone in ipairs(self.drop_zones) do
            if zone.is_active then
                local is_over = gui.pick_node(zone.node, touch.x, touch.y)
                if is_over and not zone.is_hovered then
                    zone.is_hovered = true
                    gui.animate(zone.node, "color", zone.hover_color, gui.EASING_OUTSINE, 0.2)
                elseif (not is_over) and zone.is_hovered then
                    zone.is_hovered = false
                    gui.animate(zone.node, "color", zone.color, gui.EASING_OUTSINE, 0.2)
                end
            end
        end
    end)

    element_drag_data.drag.on_drag_start:subscribe(function(_, _, _, touch)
        gui.set_parent(root, self.drag_parent or nil, true)
    end)


    -- Save start position for this specific element
    element_drag_data.start_position = gui.get_position(element_drag_data.drag.node)
    
    -- Subscribe to drag end event for this specific element
    element_drag_data.drag.on_drag_end:subscribe(function(_, _, _, touch)
        -- Drop zone tespiti
        local dropped_zone = nil
        if touch then
            for _, zone in ipairs(self.drop_zones) do
                if zone.is_active and gui.pick_node(zone.node, touch.x, touch.y) then
                    dropped_zone = zone
                    break
                end
            end
        end

        if dropped_zone then
            if self.on_item_dropped then
                self:on_item_dropped(dropped_zone.name, root)
            end
            -- Zone'a parent et ve hedef konuma animasyonla (x hizalı, y 50px aşağı)
            gui.set_parent(root, dropped_zone.node, true)
            local current_pos = gui.get_position(element_drag_data.drag.node)
            local target = vmath.vector3(0, -50, current_pos.z)
            gui.animate(element_drag_data.drag.node, "position", target, gui.EASING_OUTBACK, 0.25)
            -- Drop animasyonu (zone feedback)
            gui.set_scale(dropped_zone.node, vmath.vector3(1.2))
            gui.animate(dropped_zone.node, "scale", vmath.vector3(1), gui.EASING_OUTBACK, 0.3)
        else
            -- Hover efektlerini sıfırla ve orijinal parent/pozisyona dön
            gui.animate(element_drag_data.drag.node, "position", element_drag_data.start_position, gui.EASING_OUTBACK, 0.3)
            gui.set_parent(root, element_drag_data.parent or nil, true)
        end

        -- Hover efektlerini sıfırla
        for _, zone in ipairs(self.drop_zones) do
            if zone.is_hovered then
                zone.is_hovered = false
                gui.animate(zone.node, "color", zone.color, gui.EASING_OUTSINE, 0.2)
            end
        end
    end)
    
    -- Store drag data for this element using the root node as key
    self.element_drag_data[root] = element_drag_data

end

function init(self)
    self.druid = druid.new(self)
    self.hero_scroll = self.druid:new_scroll("hero_scroll", "hero_content")
    self.contract_scroll = self.druid:new_scroll("contract_scroll", "contract_content")


    self.drag_parent = gui.get_node("drag_parent")
    print(self.drag_parent," drag_parent")
    self.prefab = gui.get_node("box") -- Root of the element prefab
    gui.set_enabled(self.prefab, false)
    self.contract_grid = self.druid:new_grid("contract_content", self.prefab, 30)
    self.hero_grid = self.druid:new_grid("hero_content", self.prefab, 30) -- The self.prefab is a node that will be cloned to create grid elements
    self.hero_scroll:bind_grid(self.hero_grid) -- Bind the grid to the scroll
    self.contract_scroll:bind_grid(self.contract_grid) -- Bind the grid to the scroll

    -- Initialize dynamic storages
    self.element_drag_data = {}
    self.drop_zones = {}

    for i = 1, 10 do
        -- Call at any moment
        -- Use grid:remove to delete element
        add_hero_element(self, { text = "Hero " .. i }) -- You can pass data to the GUI element
    end

    for i = 1, 10 do
        -- Call at any moment
        -- Use grid:remove to delete element
        add_contract_element(self, { text = "Contract " .. i }) -- You can pass data to the GUI element
    end
    
end

function final(self)
    self.druid:final()
end

function update(self, dt)
    self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
    self.druid:on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
    return self.druid:on_input(action_id, action)
end


-- Basit drop callback (kullanıcı override edebilir)
function on_item_dropped(self, zone_name, hero_root)
    -- Burada oyun mantığına göre eşleştirme/atama yapılabilir
end


function remove_element(self)
	local last_node = table.remove(self.created_nodes)
	if last_node == nil then
		return
	end

	gui.delete_node(last_node)
	local grid_index = self.grid:get_index_by_node(last_node)
	self.grid:remove(grid_index)
end